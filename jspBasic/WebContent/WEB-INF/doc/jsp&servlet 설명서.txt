
	@WAS(Web Application Server) - Java Enterprise Edition Server

	WAS는 Web Server + Application Server + Service의 의미다.
	웹 서버는 Jsp/Servlet을 위한 웹 컨테이너와 HTML을 서비스하는 HTTP Server가 있다.
	
	Application 서버는 비즈니스 로직을 수행하는 컨테이너가 있다
	서비스는 JNDI, JMS와 같은 것을 제공하여 다른 기능의 서버와 연결하여
	사용하게 하거나 서버 안에서 편리하게 사용 할 수 있다
	
	WAS에는 WebLogic, Zeus등 수 많은 제품이 있다
	Tomcat을 WAS라고 부르기도 한다

	-클라이언트 서버 시스템 구조에서 서버 쪽 어플리케이션의 생성과 실행,
	소멸을 관리하는 프로그램을 애플리케이션 서버라 한다
	서블릿과 서블릿 컨테이너와 같이 웹 기술을 기반으로 동작되는
	애플리케이션 서버를 WAS라 부른다


	@웹 컨테이너(Web Container)
	
	웹 서버에는 HTML을 클라이언트로 보내는 HTTP 서버 Jsp/Servlet을 실행하는 엔진,
	엔진과 Jsp/Servlet을 실행하는데 필요한 라이브러리등을 포함한 웹 컨테이너가 있다.
	웹 프로그래밍에는 웹 컨테이너가 반드시 있어야 한다.

	@서블릿(Servlet)
	서블릿은 컨테이너에서 실행되는 프로그램이다
	요청에 대한 내용을 처리하고 결과를 HTML로 만든다
	자바 코드로 구현한다
	
	@JSP(Java Server Page)
	자바 서버 페이지의 약자로 서버에서 실행되는 웹 프로그래밍용
	클래스를 말한다
	jsp로 된 파일은 서블릿으로 변환된다
	jsp도 서블릿임으로 서블릿에서 사용하는 객체나 메서드를 jsp에서도
	사용 할 수 있다

	@웹 프로젝트 폴더 구조
	
	-src
	자바 소스 파일을 두는 폴더
	이 폴더에서 서블릿 클래스나 필터, 리스너 등 필요한 모든 자바 클래스 파일을 둔다.
	
	-build/classes
	컴파일 된 자바 클래스 파일(.class)이 놓이는 폴더이다
	물론 패키지에 소속 된 클래스인 경우 이 폴더에 해당 패키지가 자동으로 만들어진다
	
	-WebContent
	HTML(.html), CSS(.css),Javascript(.js), jsp, 이미지 파일 등
	웹 컨텐츠를 두는 폴더이다
	웹 애플리케이션을 서버에 배치할 대 이 폴더의 내용들이 그대로 복사된다
	
	-WebContent/ WEB-INF(Information)
	웹 애플리케이션의 설정과 관련된 파일을 두는 폴더이다
	이 폴더에 있는 파일은 클라이언트에서 요청 할 수 없다
	따라서 html등의 클라이언트에서 요청 할 파일을 이 폴더에 두어서는 안 된다.
	
	-WebContent/ WEB-INF/ web.xml
	애플리케이션 배치 설명서(Deployment Descriptor) 파일이다. 
	영어 표현으로는 줄여서 DD파일이라고 부른다
	서블릿이나 필터, 매개변수, 기본 웹 페이지 등
	웹 애플리케이션 컴포넌트들의 배치 정보를 이 파일에 작성한다
	서블릿 컨테이너는 클라이언트 요청을 처리 할 때 이 파일의 정보를 참고하여 
	서블릿 클래스를 찾거나 필터를 수행하는 등의 작업을 수행한다
	엄청 중요한 것이 xml 파일이다
	
	-WebContent/ WEB-INF/ lib
	자바 아카이브 파일(.jar)을 두는 폴더이다





	@서블릿의 라이프 사이클(Life Cycle)
	웹 프로그래밍은 컨테이너가 반드시 필요하며
	프로그래밍을 엔진에서 실행하여 원하는 결과를 생성한다
	
	서블릿은 컨테이너의 명령에 따라 생성, 초기화, 실행, 소멸등
	정해진 행동을 한다
	이렇게 하는 것을 라이프 사이클이라고 한다
	서블릿은 요청을 처음으로 받으면 서블릿을 생성한다
	
	init -> service -> destroy를 호출하게 된다
	일반적으로 init 메서드를 호출하여 service를 호출한다
	서비스를 계속 수행하다 더 이상 요청이 없다면 destroy 메서드를 
	호출하여 자원을 회수하고 서블릿 객체를 제거한다
	컨테이너는 초기화와 소멸 메서드를 한 번만 호출한다


@ServletRequest -> 주소값이 왔거나 이벤트가 발생한 순간에 그 정보가 리퀘스트에 담긴다.
클라이언트의 요청 정보를 다룰 때 사용된다.


@ServletResponse -> 그 정보를 받아서 서버에서 재가공하거나 다른 화면에 제공하는 역할이다.
응답과 관련된 기능을 제공한다
클라이언트에게 출력하는 내용에 해당하는 모든 정보들이 담겨 있다

JDBC(Java DataBase Connectivity) ->이것도 API이다.
프로그램과 DB를 연결하여 데이터를 주고 받을 수 있게 해 주는 프로그래밍 인터페이스(API)

HTTP 응답 상태 코드
statecode		설명
200         요청이 성공적으로 처리됨
301         요청한 자원이 이동함, 헤더 정보에 이동 위치를 알려줄 테니 다시 요청바람
304         클라이언트가 임시 보관함 응답결과와 다르지 않다
400         잘못된 요청이다 -> 사용하는 사람의 잘못이다
404         요청한 자원을 못 찾았다
405         메서드 허용 안됨
500         서버 내부에서 오류가 발생했다 -> 우리 잘못이다

@Statement VS PreparedStatement

비교항목						Statement					PreparedStatement

실행속도				질의할 때마다 sql문을 컴파일 한다		sql문을 미리 준비하여 컴파일해 둔다
													입력 매개변수 값만 추가하여 서버에
													전송한다. 특히 여러 번 반복하여 질의하는
													경우, 실행속도가 빠름
													
바이너리 데이터 전송		불가능							가능

프로그래밍 편의성		sql문 안에 있는 입력 매개변수 값이		sql과 입력 매개변수가 분리되어 있어서
					포함되어 있어서 sql문이 				코드작성이 편리하다
					복잡하고 매개변수가 여러 개인 경우
					코드 관리가 힘들다
					보안이 안 됨						보안이 됨

@GET VS POST 요청
GET 특징
-url에 데이터를 포함 -> 데이터 조회에 적합
-바이너리 및 대용량 데이터 전송 불가
-요청라인과 헤드 필드의 최대 크기
	http사양에는 제한사항 없음
	대용량 url로 인한 문제 발생 -> 웹 서버에 따라 최대 크기 제한
	
@GET 요청을 발생시키는 방법
1. 웹 브라우저 주소창에 url을 입력하는 경우
2. 링크를 클릭하는 경우(a 태그)
3. 입력 폼의 method 속성값이 get인 경우

@GET의 쓰임새
-자료를 검색한다거나, 게시그르이 정보를 본다거나, 특정 상품의 정보를 조회하는 것과
같이 데이터를 조회하는 경우에 적합하다
url에 검색어나 게시글 번호를 포함할 수 있기 때문에 메일이나 단문 메세지 등을 통해
다른 사람에게 전달하기가 쉽다
또한 즐겨찾기에 저장해 두면 언제든지 해당 페이지로 바로 찾아갈 수 있어 매우 편리하다

@단점
보안에 좋지 않다 - 입력한 정보가 그대로 노출됨
로그인이나 개인정보 관리와 같은 보안을 요구하는 경우에는 get요청을 하지 말아야 한다

-바이너리 데이터 전송 불가
파일을 전송 할 수 없다
이미지, 동영상등은 바이너리 파일이다
정보가 너무 크면 웹 서버에서 처리할 수 없기 때문에 바이너리를 전송하기에는 get은 적합하지 않다

@POST 특징
-url에 데이터가 포함되지 않음 -> 외부 노출 방지
-메세지 본문에 데이터 포함 -> 실행 결과 공유 불가
-바이너리 및 대용량 데이터 전송 가능

@POST 장점
입력값을 url에 노출하지 않는다

@POST 단점
요청 결과를 공유할 수 없다

@POST 요청을 발생시키는 방법
1. 입력 폼의 method 속성값이 post인 경우

@POST 쓰임새
로그인이나 결제정보와 같이 보안이 중요한 사항에 post를 사용
대용량 데이터들이 사용되는 곳에 사용

@TMI
get은 post보다 전송 속도가 빠르다

@컨텍스트 (Context)
배포단위, 실행단위의 디렉토리를 컨텍스트라고 한다
jsp 프로젝트의 경우 일반적으로 WebContent가 해당

@필터(filter)
필터는 서블릿 실행 전후에 어떤 작업을 하고자 할 때 사용하는 기술이다
ex: 클라이언트가 보낸 데이터를 암호 해제하거나
서블릿이 실행되기 전에 필요한 자원을 미리 준비한다거나
서블릿이 실행 될 때마다 로그를 남긴다거나 등의
작업을 필터를 통해 처리 할 수 있다

요청 -> 서블릿 컨테이너 -> 필터1 -> 필터2 -> 서블릿
	<-			<-		<-		<-


@Web History
-only servlet
계층구조
url mapping

-spaghetti & separation(MVC 1ver)
view + viewLogic

scriptlet
DTO

@MVC 이해하기
MVC(Model-View-Controller)
아키텍쳐라고도 하며 
모델, 뷰, 컨트롤러로 구분한다

-컨트롤러 컴포넌트의 역할
클라이언트 요청을 받았을 때 그 요청에 대해 실제 업무를 수행하는 모델 컴포턴트를 호출하는 일이다
또한 클라이언트가 보낸 데이터가 있다면, 모델을 호출 할 때 전달하기 쉽게 데이터를 적절히
가공하는 일을 한다
모델이 업무 수행을 완료하면, 그 결과를 가지고 화면을 생성하도록 뷰에게 전달한다
즉 클라이언트 요청에 대해 모델과 뷰를 결정하여 전달하는 일을 한다
일종의 조정자라고 할 수 있다

-모델 컴포넌트 역할
데이터 저장소(데이터베이스, 디렉터리 서비스등)와 연동하여 사용자가 입력한 데이터나
사용자에게 출력 할 데이터를 다루는 일을 한다
특히 여러 개의 데이터 변경 작업을 하나의 작업으로 묶은 트랜잭션을 다루는 일도 한다

-뷰 컴포넌트 역할
모델이 처리한 데이터나 그 작업 결과를 가지고 사용자에게 출력 할 화면을 만드는 일을 한다
이렇게 생성 된 화면은 웹 브라우저가 출력한다
즉 뷰는 HTML과 CSS, JavaScript를 사용하여 웹 브라우저가 출력할 UI를 만든다

@MVC 이점
-높은 재사용성, 넓은 융통성
쉽게 교체 가능
원 소스 멀티 유즈
코드 재사용

-빠른 개발, 저렴한 비용
다른 프로젝트에서도 모델을 재사용 할 수 있다
소스 코드를 역할에 따라 나누었기 때문에 난이도에 따라 더 낮은 수준의 개발자와 협업이 가능하다

@MVC의 구동 원리 
컨트롤 요청 -> 요청 분석, 해결할 모델 찾아 실행 -> 모델은 쿼리를 실행하고 결과 얻음
-> 해당화면으로 이동하여 모델에서 얻은 데이터를 동적으로 처리(HTML로 랜더링) -> 브라우저 화면 응답

@DTO(Data Transfer Object, 데이터 전송 객체)
데이터베이스 테이블에 해당하는 객체로 테이블으 ㅣ컬럼들을 일대일로 저장 할 수 있는
멤버필드가 있고 get/set 패턴의 매서드를 갖는다
데이터베이스와 매우 빌접 한 관련이 있는 객체이며 모델에 해당한다.

@서블릿끼라 작업을 위임하는 방법
인클루딩

포워딩
